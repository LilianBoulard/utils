"""
Provides tools to analyze the files based on their extension.
"""

import pickle
import argparse
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from time import time


extension_column_name = 'extension'


def get_file_count_by_extension(dataframe):
    """
    Returns a dictionary mapping containing as key the extension,
    and as value the total number of files of this type.
    """
    count = {}
    for ext in dataframe[extension_column_name].unique():
        count[ext] = dataframe[dataframe[extension_column_name] == ext].shape[0]
    return count


def get_total_size_by_extension(dataframe: pd.DataFrame):
    """
    Returns a dictionary mapping containing as key the extension,
    and as value the total size this type of file occupies in bytes.
    """
    total_sizes = {}
    for ext in dataframe[extension_column_name].unique():
        all_files_by_ext = dataframe[dataframe[extension_column_name] == ext]
        total_sizes[ext] = all_files_by_ext['size'].sum()
    return total_sizes


def sort_dict(d: dict) -> dict:
    return dict(sorted(d.items(), key=lambda pair: pair[1]))


def pie_chart(dictionary: dict, thre: float, fil: str) -> None:
    """
    Displays a pie chart of the data passed.

    :param dict dictionary: Dictionary to analyze.
    :param int thre: Ranges from 0.0 to 100.0.
                          Values representing less than this percentage
                          will be aggregated in a single dummy value.
    :param str fil: Filter by extension
    """

    def func(percentage, all_values):
        """
        Used to convert sizes to readable values.
        """
        absolute = int(percentage / 100. * np.sum(all_values))
        # Cast the size to the best possible "size bound"
        # (idk how to say that)
        # e.g. if a file is 20 000 bytes, cast to ~20KB
        for s in size_mapping:
            if absolute < 1024:
                size = s
                break
            else:
                absolute /= 1024
        else:
            size = size_mapping
        return "{:.1f}%\n{:.1f}{}".format(percentage, absolute, size)

    size_mapping = [
        'B',
        'KB',
        'MB',
        'GB',
        'TB',
        'EB',
    ]
    # Apply filter
    dictionary = {k: v for k, v in dictionary.items() if fil in k}
    # Calculate threshold value
    total = sum(dictionary.values())
    threshold_value = int(total * (thre / 100))
    # Apply threshold ; sizes under the threshold value are aggregated.
    dictionary = {
        k: v
        for k, v in dictionary.items()
        if v > threshold_value
    }
    # Add the "Others" value
    diff = total - sum(dictionary.values())
    dictionary.update({'Others': diff})
    # Sort the dictionary again, to place "Others" correctly.
    dictionary = sort_dict(dictionary)

    # Extracts sets
    labels = list(dictionary.keys())
    uses = list(dictionary.values())
    # Display pie
    fig, ax = plt.subplots(figsize=(9, 8))
    ax.pie(uses, labels=labels, startangle=140,
           autopct=lambda pct: func(pct, uses))
    ax.set_title(f'Disk usage by extension')
    plt.show()


def histogram(dictionary: dict, thre: float, fil: str):

    # Apply filter
    dictionary = {k: v for k, v in dictionary.items() if fil in k}
    # Calculate threshold value
    total = sum(dictionary.values())
    threshold_value = int(total * (thre / 100))
    # Apply threshold ; sizes under the threshold value are aggregated.
    dictionary = {k: v for k, v in dictionary.items() if v > threshold_value}
    # Add the "Others" value
    diff = total - sum(dictionary.values())
    dictionary.update({'Others': diff})
    # Sort the dictionary again, to place "Others" correctly.
    dictionary = sort_dict(dictionary)

    # Extracts sets
    labels = list(dictionary.keys())
    uses = list(dictionary.values())
    # Convert uses to gigabytes
    uses = [use / (1024 ** 3) for use in uses]
    # Display histogram
    x = np.arange(len(dictionary))
    fig, ax = plt.subplots(figsize=(14, 8))
    ax.bar(x, height=uses)
    plt.xticks(x, labels)
    ax.set_xlabel('Extension')
    ax.set_ylabel('Space used in GB')
    ax.set_title(f'Disk usage by extension')
    plt.show()


def save_dict(d: dict, name: str = 'sizes_by_extension.pickle') -> None:
    with open(name, 'wb') as fl:
        pickle.dump(d, fl)


def load_dict(name: str = 'sizes_by_extension.pickle') -> dict:
    with open(name, 'rb') as fl:
        d = pickle.load(fl)
    return d


###############
# ARGS PARSER #
###############

parser = argparse.ArgumentParser(
    'Utility used to read a serialized DataFrame generated by "files_to_dataframe.py", '
    'and show the usage of the root directory by extension type.'
)

parser.add_argument("-f", "--file",
                    help="Path to the file that contains "
                         "the serialized DataFrame.",
                    type=str, nargs=1)
parser.add_argument("--byext",
                    help="Filters graphs to only display on extension type."
                         "Usually, 'gz'.",
                    type=str, nargs=1)
parser.add_argument("--pie",
                    help="Displays a pie chart at the end of the execution. "
                         "False by default, specify for True",
                    action="store_true")
parser.add_argument("--threshold",
                    help="Threshold used to simplify the charts. "
                         "It is a percentage expressed between 0.0 and 100.0. "
                         "All values representing less than this "
                         "percentage of the total will be aggregated together. "
                         "Default is 1.0, which is 1 percent.",
                    type=float, nargs=1)
parser.add_argument("--hist",
                    help="Displays an histogram at the end of the execution. "
                         "False by default, specify for True",
                    action="store_true")
parser.add_argument("--load",
                    help="Loads the dictionary saved in the file 'sizes_by_extension.pickle'."
                         "Will not compute the sizes if specified.",
                    action="store_true")
parser.add_argument("--save",
                    help="Saves the sizes once computed to 'sizes_by_extension.pickle'.",
                    action="store_true")
parser.add_argument("--print",
                    help="Prints the sizes dictionary.",
                    action="store_true")

args = parser.parse_args()

if args.file:
    file = args.file[0]

if args.byext:
    ext_filter = args.byext[0]
else:
    ext_filter = ''

if args.pie:
    pie = True
else:
    pie = False

if args.hist:
    hist = True
else:
    hist = False

if args.threshold:
    threshold = args.threshold[0]
else:
    threshold = 1.0  # 1%

if args.load:
    load = True
else:
    load = False

if args.save:
    save = True
else:
    save = False

if args.print:
    print_sizes = True
else:
    print_sizes = False


if __name__ == '__main__':

    if load:
        print('Loading dictionary from file')
        t = time()
        sizes = load_dict()
        print('Took {:.3f}s'.format(time() - t))
    else:
        # Import df
        print('Reading DataFrame from file')
        t = time()
        df = pd.read_parquet(file, engine='fastparquet')
        print('Took {:.3f}s'.format(time() - t))

        # The DataFrame has two columns:
        # 1. path
        #   - The full path of the file
        # 2. size
        #   - The file's size, in bytes
        # 3. extension
        #   - The file's extension, empty if it does not have one

        print('Getting sizes by extension')
        t = time()
        unsorted_sizes = get_total_size_by_extension(df)
        print('Took {:.3f}s'.format(time() - t))

        print('Sorting results')
        t = time()
        sizes = sort_dict(unsorted_sizes)
        print('Took {:.3f}s'.format(time() - t))

    if pie:
        print('Displaying pie chart')
        pie_chart(sizes, threshold, fil=ext_filter)

    if hist:
        print('Displaying histogram')
        histogram(sizes, threshold, fil=ext_filter)

    if print_sizes:
        print(sizes)

    if save:
        print('Saving sizes to file')
        t = time()
        save_dict(sizes)
        print('Took {:.3f}s'.format(time() - t))
